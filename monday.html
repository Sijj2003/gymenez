# ====================================================================
# UTILIDAD: MAPEO DE DÍAS (MANTENIDO)
# ====================================================================

def get_day_index(day_name_spanish):
    """Convierte nombre del día en español a índice de Python (Lunes=0, Domingo=6)."""
    day_map = {
        'Lunes': 0,
        'Martes': 1,
        'Miércoles': 2,
        'Jueves': 3,
        'Viernes': 4,
        'Sábado': 5,
        'Domingo': 6
    }
    return day_map.get(day_name_spanish)

# ====================================================================
# ENDPOINT CORREGIDO: COMPROBAR BLOQUEO DE RUTINA POR CICLO SEMANAL
# ====================================================================
@app.route('/api/journal/check_block_status/<user_id>/<routine_day>', methods=['GET'])
def check_block_status(user_id, routine_day):
    """
    Verifica si una rutina específica (e.g., 'Martes') está bloqueada.
    El bloqueo se activa si la rutina fue completada después del último reinicio de ciclo
    (último [routine_day] a las 00:01 AM UTC).
    """
    # journal_collection y firestore deben estar disponibles globalmente/importados
    if journal_collection is None:
         return jsonify({'success': False, 'error': 'El servidor no pudo inicializar la base de datos (503).'}), 503

    routine_day_index = get_day_index(routine_day)
    if routine_day_index is None:
        return jsonify({'success': False, 'error': f'Día de rutina no válido: {routine_day}'}), 400

    try:
        # 1. OBTENER LA ÚLTIMA SESIÓN COMPLETADA DE ESTE DÍA ESPECÍFICO
        # Usamos DESCENDING importado de google.cloud.firestore_v1.query
        last_session_query = journal_collection.where('userId', '==', user_id)\
                                                .where('day', '==', routine_day)\
                                                .order_by('dateCompleted', direction=DESCENDING)\
                                                .limit(1)\
                                                .get() # .get() ejecuta la consulta y devuelve una lista de documentos

        # ⚠️ CRÍTICO: Comprobar si la lista de resultados está vacía
        if not last_session_query:
            # Nunca se ha hecho esta rutina, no hay bloqueo.
            return jsonify({'success': True, 'isBlocked': False, 'nextDay': routine_day}), 200

        last_session_doc = last_session_query[0]
        # Obtener el timestamp directamente del documento (objeto google.cloud.firestore.Timestamp)
        last_completed_timestamp = last_session_doc.to_dict().get('dateCompleted')

        if not last_completed_timestamp:
             # El documento existe pero no tiene la marca de tiempo (situación inusual)
             return jsonify({'success': True, 'isBlocked': False, 'nextDay': routine_day}), 200

        # Obtener el tiempo de la última completación como datetime UTC
        # El objeto Timestamp de Firestore tiene un método .astimezone(datetime.timezone.utc)
        # Aquí asumimos que last_completed_timestamp ya es un objeto Timestamp de Firestore
        # que puede convertirse a datetime.datetime
        last_completed_date = last_completed_timestamp.astimezone(datetime.timezone.utc)
        now_utc = datetime.datetime.now(datetime.timezone.utc)

        # 2. CALCULAR EL PUNTO DE REINICIO DE CICLO (ÚLTIMO [routine_day] 00:01 AM UTC)

        # Determinar cuántos días retroceder desde hoy para llegar al día de la rutina.
        # now_utc.weekday() da el índice del día actual (0=Lunes, 6=Domingo).
        days_to_roll_back = (now_utc.weekday() - routine_day_index + 7) % 7

        last_reset_date = now_utc.date() - timedelta(days=days_to_roll_back)

        # El punto de reinicio del ciclo (T_reset_last) es el día de la rutina a las 00:01:00 UTC
        T_reset_last = datetime.datetime.combine(
            last_reset_date,
            datetime.time(0, 1, 0), # Usamos 00:01:00 para asegurar que sea después del día anterior
            tzinfo=datetime.timezone.utc
        )

        # 3. DETERMINAR EL ESTADO DE BLOQUEO

        # Está bloqueado si la rutina fue completada DESPUÉS del último punto de reinicio.
        # Es decir, si el registro de la rutina se creó en el ciclo semanal actual.
        is_blocked = last_completed_date > T_reset_last

        return jsonify({
            'success': True,
            'isBlocked': is_blocked,
            'lastCompleted': last_completed_date.isoformat(), # Útil para depuración
            'resetPoint': T_reset_last.isoformat(), # Útil para depuración
            'nextDay': routine_day
        }), 200

    except Exception as e:
        import sys
        print(f"Error en check_block_status: {e}", file=sys.stderr)
        # Loguear el traceback completo si es posible en un entorno real.
        return jsonify({'success': False, 'error': f'Error interno al verificar la actividad: {e}'}), 500
